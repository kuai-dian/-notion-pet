/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { isVNode, defineComponent, ref, provide, toRefs, createVNode, mergeProps } from 'vue';
import throttle from 'lodash/throttle';
import mixins from '../../utils/mixins.js';
import getConfigReceiverMixins from '../../config-provider/config-receiver.js';
import { prefix } from '../../config.js';
import { flatColumns } from '../util/props-util.js';
import baseTableProps from '../base-table-props.js';
import TableBody from './table-body.js';
import TableHeader from './table-header.js';
import TableColGroup from './col-group.js';
import { Pagination } from '../../pagination/index.js';
import { Loading } from '../../loading/index.js';
import { debounce, getScrollDirection, ScrollDirection } from '../util/common.js';
import { renderTNodeJSX } from '../../utils/render-tnode.js';
import { EVENT_NAME_WITH_KEBAB } from '../util/interface.js';
import { emitEvent } from '../../utils/event.js';
import { getPropsApiByEvent } from '../../utils/helper.js';
import { SIZE_CLASSNAMES } from '../../utils/classnames.js';
import useVirtualScroll from '../../hooks/virtualScroll.js';
import '../../config-provider/zh_CN_config.js';
import '../../config-provider/type.js';
import 'lodash/get';
import 'lodash/camelCase';
import './table-row.js';
import './table-cell.js';
import '../../popup/index.js';
import '../../popup/popup.js';
import '@babel/runtime/helpers/typeof';
import '@popperjs/core';
import '../../_chunks/dep-b66bfe36.js';
import '../../utils/dom.js';
import 'lodash/isString';
import '../../utils/easing.js';
import '../../popup/props.js';
import '../../utils/set-style.js';
import '../../utils/map-props.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import 'lodash/kebabCase';
import '../../utils/withInstall.js';
import './style/css.js';
import '../../popup/type.js';
import 'lodash/isEmpty';
import 'lodash/isFunction';
import 'lodash/isObject';
import '@babel/runtime/helpers/slicedToArray';
import '../primary-table-props.js';
import '../../pagination/pagination.js';
import 'tdesign-icons-vue-next';
import '../../input-number/index.js';
import '../../input-number/input-number.js';
import '@babel/runtime/helpers/asyncToGenerator';
import '@babel/runtime/regenerator';
import '../../button/index.js';
import '../../button/button.js';
import '../../button/props.js';
import '../../utils/ripple.js';
import '../../loading/loading.js';
import '../../loading/icon/gradient.js';
import '../../_common/js/loading/circle-adapter.js';
import '../../_common/js/utils/set-style.js';
import '../../_common/js/utils/helper.js';
import '../../utils/transfer-dom.js';
import '../../loading/props.js';
import '../../loading/type.js';
import '../../loading/plugin.js';
import '../../button/type.js';
import '../../input-number/props.js';
import '../../input-number/type.js';
import '../../select/index.js';
import '../../select/select.js';
import 'lodash/debounce';
import 'lodash/set';
import '../../input/index.js';
import '../../input/addon.js';
import '../../input/input.js';
import '../../input/props.js';
import '../../input/input-group.js';
import '../../input/type.js';
import '../../tag/index.js';
import '../../tag/tag.js';
import '../../tag/props.js';
import '../../tag/check-tag.js';
import '../../tag/check-tag-props.js';
import '../../tag/type.js';
import '../../common-components/fake-arrow.js';
import '../../select/option.js';
import '../../select/option-props.js';
import '../../checkbox/index.js';
import '../../checkbox/checkbox.js';
import '../../checkbox/props.js';
import '../../checkbox/group.js';
import 'lodash/intersection';
import '../../checkbox/checkbox-group-props.js';
import '../../checkbox/type.js';
import '../../select/props.js';
import '../../select/optionGroup.js';
import '../../select/option-group-props.js';
import '../../select/type.js';
import '../../pagination/props.js';
import '../../pagination/type.js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !isVNode(s);
}

var _BaseTable = defineComponent(_objectSpread(_objectSpread({}, mixins(getConfigReceiverMixins("table"))), {}, {
  name: "TBaseTable",
  components: {
    TableBody: TableBody,
    TableHeader: TableHeader,
    TableColGroup: TableColGroup,
    Pagination: Pagination
  },
  props: _objectSpread(_objectSpread({}, baseTableProps), {}, {
    onRowDragover: Function,
    onRowDragstart: Function,
    provider: {
      type: Object,
      "default": function _default() {
        return {};
      }
    }
  }),
  emits: ["page-change", "scroll-x", "scroll-y"].concat(_toConsumableArray(EVENT_NAME_WITH_KEBAB)),
  setup: function setup(props) {
    var scrollBody = ref(null);
    provide("scrollBody", scrollBody);

    var _ref = props.scroll || {},
        type = _ref.type,
        rowHeight = _ref.rowHeight,
        _ref$bufferSize = _ref.bufferSize,
        bufferSize = _ref$bufferSize === void 0 ? 20 : _ref$bufferSize,
        _ref$isFixedRowHeight = _ref.isFixedRowHeight,
        isFixedRowHeight = _ref$isFixedRowHeight === void 0 ? false : _ref$isFixedRowHeight;

    var _toRefs = toRefs(props),
        data = _toRefs.data;

    var _ref2 = type === "virtual" ? useVirtualScroll({
      container: scrollBody,
      data: data,
      fixedHeight: isFixedRowHeight,
      lineHeight: rowHeight,
      bufferSize: bufferSize
    }) : {},
        _ref2$trs = _ref2.trs,
        trs = _ref2$trs === void 0 ? null : _ref2$trs,
        _ref2$scrollHeight = _ref2.scrollHeight,
        scrollHeight = _ref2$scrollHeight === void 0 ? null : _ref2$scrollHeight,
        _ref2$visibleData = _ref2.visibleData,
        visibleData = _ref2$visibleData === void 0 ? null : _ref2$visibleData,
        _ref2$translateY = _ref2.translateY,
        translateY = _ref2$translateY === void 0 ? null : _ref2$translateY,
        _ref2$handleScroll = _ref2.handleScroll,
        handleScroll = _ref2$handleScroll === void 0 ? null : _ref2$handleScroll,
        _ref2$handleRowMounte = _ref2.handleRowMounted,
        handleRowMounted = _ref2$handleRowMounte === void 0 ? null : _ref2$handleRowMounte;

    return {
      scrollType: type,
      rowHeight: rowHeight,
      trs: trs,
      bufferSize: bufferSize,
      scrollBody: scrollBody,
      scrollHeight: scrollHeight,
      visibleData: visibleData,
      translateY: translateY,
      handleRowMounted: handleRowMounted,
      handleVirtualScroll: handleScroll
    };
  },
  data: function data() {
    return {
      scrollableToLeft: false,
      scrollableToRight: false,
      scrollBarWidth: 0,
      defaultCurrent: 0,
      defaultPageSize: 0,
      useFixedHeader: false
    };
  },
  computed: {
    current: function current() {
      var _this$pagination, _this$pagination2;

      return ((_this$pagination = this.pagination) === null || _this$pagination === void 0 ? void 0 : _this$pagination.current) || this.defaultCurrent || ((_this$pagination2 = this.pagination) === null || _this$pagination2 === void 0 ? void 0 : _this$pagination2.defaultCurrent);
    },
    pageSize: function pageSize() {
      var _this$pagination3, _this$pagination4;

      return ((_this$pagination3 = this.pagination) === null || _this$pagination3 === void 0 ? void 0 : _this$pagination3.pageSize) || this.defaultPageSize || ((_this$pagination4 = this.pagination) === null || _this$pagination4 === void 0 ? void 0 : _this$pagination4.defaultPageSize);
    },
    dataSource: function dataSource() {
      if (!this.hasPagination) return this.data.slice(0);
      var current = this.current,
          pageSize = this.pageSize;

      if (this.data.length > pageSize) {
        return this.data.slice((current - 1) * pageSize, current * pageSize);
      }

      return this.data;
    },
    flattedColumns: function flattedColumns() {
      return flatColumns(this.columns);
    },
    isEmpty: function isEmpty() {
      return (!this.dataSource || this.dataSource.length === 0) && !this.loading;
    },
    hasFixedColumns: function hasFixedColumns() {
      var columns = this.columns;
      return columns.some(function (item) {
        return item.fixed === "right" || item.fixed === "left";
      });
    },
    hasPagination: function hasPagination() {
      return !!this.pagination;
    },
    isLoading: function isLoading() {
      return !!this.loading;
    },
    tableHeight: function tableHeight() {
      var height = this.height,
          maxHeight = this.maxHeight,
          useFixedHeader = this.useFixedHeader,
          isEmpty = this.isEmpty;

      if (isEmpty) {
        return "auto";
      }

      if (height !== "auto" && height) {
        return height;
      }

      if (maxHeight && useFixedHeader) {
        return maxHeight;
      }

      return "auto";
    },
    fixedHeader: function fixedHeader() {
      var tableHeight = this.tableHeight;
      return tableHeight !== "auto";
    },
    commonClass: function commonClass() {
      var _ref3;

      var classes = ["".concat(prefix, "-table"), (_ref3 = {}, _defineProperty(_ref3, SIZE_CLASSNAMES.small, this.size === "small"), _defineProperty(_ref3, SIZE_CLASSNAMES.large, this.size === "large"), _defineProperty(_ref3, "".concat(prefix, "-table--bordered"), this.bordered), _defineProperty(_ref3, "".concat(prefix, "-table--striped"), this.stripe), _defineProperty(_ref3, "".concat(prefix, "-table--hoverable"), this.hover), _defineProperty(_ref3, "".concat(prefix, "-table__row--draggable"), this.provider.sortOnRowDraggable), _defineProperty(_ref3, "".concat(prefix, "-table-table--align-top"), this.verticalAlign === "top"), _defineProperty(_ref3, "".concat(prefix, "-table-table--align-bottom"), this.verticalAlign === "bottom"), _defineProperty(_ref3, "".concat(prefix, "-table__cell--fixed"), this.hasFixedColumns), _defineProperty(_ref3, "".concat(prefix, "-table--has-fixed"), this.hasFixedColumns), _defineProperty(_ref3, "".concat(prefix, "-table__header--fixed"), this.fixedHeader), _ref3)];
      return classes;
    },
    usePadding: function usePadding() {
      return this.fixedHeader || this.scrollableToRight || this.scrollableToLeft;
    }
  },
  mounted: function mounted() {
    var _this = this;

    if (this.hasFixedColumns) {
      setTimeout(function () {
        _this.checkScrollableToLeftOrRight();
      }, 0);
      this.addWindowResizeEventListener();
    }

    var scrollDiv = document.createElement("div");
    scrollDiv.style.cssText = "\n      width: 99px;\n      height: 99px;\n      overflow: scroll;\n      position: absolute;\n      top: -9999px;";
    scrollDiv.classList.add("scrollbar");
    document.body.appendChild(scrollDiv);
    this.scrollBarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    var maxHeight = this.maxHeight;
    this.checkMaxHeight();
  },
  unmounted: function unmounted() {
    window.removeEventListener("resize", debounce(this.checkScrollableToLeftOrRight));
  },
  updated: function updated() {
    this.checkMaxHeight();
  },
  methods: {
    checkScrollableToLeftOrRight: function checkScrollableToLeftOrRight() {
      var scrollContainer = this.$refs[this.fixedHeader ? "scrollBody" : "tableContent"];
      if (!scrollContainer) return;
      var scrollLeft = scrollContainer.scrollLeft,
          scrollWidth = scrollContainer.scrollWidth,
          clientWidth = scrollContainer.clientWidth;
      this.scrollableToLeft = scrollLeft > 0;
      this.scrollableToRight = scrollLeft + clientWidth < scrollWidth;
    },
    addWindowResizeEventListener: function addWindowResizeEventListener() {
      window.addEventListener("resize", debounce(this.checkScrollableToLeftOrRight));
    },
    renderHeader: function renderHeader() {
      var columns = this.columns,
          $slots = this.$slots,
          bordered = this.bordered;
      return createVNode(TableHeader, {
        "columns": columns,
        "bordered": bordered
      }, $slots);
    },
    renderBody: function renderBody() {
      var _this2 = this;

      var $slots = this.$slots;
      var rowEvents = {};
      EVENT_NAME_WITH_KEBAB.concat(["row-dragstart", "row-dragover"]).forEach(function (eventName) {
        rowEvents[getPropsApiByEvent(eventName)] = function (params) {
          emitEvent(_this2, eventName, params);
        };
      });
      var props = {
        rowKey: this.rowKey,
        data: this.scrollType === "virtual" ? this.visibleData : this.dataSource,
        provider: this.provider,
        columns: this.flattedColumns,
        rowClassName: this.rowClassName,
        current: this.current,
        rowspanAndColspan: this.rowspanAndColspan,
        firstFullRow: this.firstFullRow,
        lastFullRow: this.lastFullRow,
        scrollType: this.scrollType,
        rowHeight: this.rowHeight,
        trs: this.trs,
        bufferSize: this.bufferSize,
        handleRowMounted: this.handleRowMounted
      };
      return createVNode(TableBody, mergeProps(props, rowEvents), _isSlot($slots) ? $slots : {
        "default": function _default() {
          return [$slots];
        }
      });
    },
    renderEmptyTable: function renderEmptyTable() {
      var useLocale = !this.empty && !this.$slots.empty;
      var height = this.height;
      var wrapperStyle = {};

      if (height !== "auto") {
        wrapperStyle.height = isNaN(Number(height)) ? height : "".concat(height, "px");
      }

      return createVNode("div", {
        "style": wrapperStyle,
        "class": "".concat(prefix, "-table__empty")
      }, [useLocale ? this.global.empty : renderTNodeJSX(this, "empty")]);
    },
    renderPagination: function renderPagination() {
      var _this3 = this;

      var paginationProps = this.pagination;
      return createVNode("div", {
        "class": "".concat(prefix, "-table__pagination")
      }, [createVNode(Pagination, mergeProps(paginationProps, {
        onChange: function onChange(pageInfo) {
          paginationProps.onChange && paginationProps.onChange(pageInfo);
        },
        onCurrentChange: function onCurrentChange(current, pageInfo) {
          emitEvent(_this3, "page-change", pageInfo, _this3.dataSource);
          _this3.defaultCurrent = current;
          paginationProps.onCurrentChange && paginationProps.onCurrentChange(current, pageInfo);
        },
        onPageSizeChange: function onPageSizeChange(pageSize, pageInfo) {
          emitEvent(_this3, "page-change", pageInfo, _this3.dataSource);
          _this3.defaultPageSize = pageSize;
          paginationProps.onPageSizeChange && paginationProps.onPageSizeChange(pageSize, pageInfo);
        }
      }), null)]);
    },
    renderTableWithFixedHeader: function renderTableWithFixedHeader() {
      var _this4 = this;

      var fixedTable = [];
      var columns = this.columns,
          asyncLoadingProps = this.provider.asyncLoadingProps,
          tableLayout = this.tableLayout,
          scrollBarWidth = this.scrollBarWidth,
          hasFixedColumns = this.hasFixedColumns,
          tableHeight = this.tableHeight,
          usePadding = this.usePadding;
      var handleScroll = throttle(function (e) {
        var target = e.target;
        var scrollLeft = target.scrollLeft;
        _this4.$refs.scrollHeader.scrollLeft = scrollLeft;

        _this4.handleScroll(e);

        _this4.scrollType === "virtual" && _this4.handleVirtualScroll();
      }, 10);
      var paddingRight = "".concat(scrollBarWidth, "px");
      var headerContainerStyle = columns.length > 1 && usePadding ? {
        paddingRight: paddingRight
      } : {};
      fixedTable.push(createVNode("div", {
        "class": "".concat(prefix, "-table__header"),
        "style": headerContainerStyle,
        "ref": "scrollHeader"
      }, [createVNode("table", {
        "style": {
          tableLayout: tableLayout
        }
      }, [createVNode(TableColGroup, {
        "columns": columns
      }, null), this.renderHeader()])]));
      var containerStyle = {
        height: isNaN(Number(tableHeight)) ? tableHeight : "".concat(Number(tableHeight), "px"),
        width: hasFixedColumns ? "100%" : void 0,
        position: "relative",
        overscrollBehavior: "none"
      };
      var isVirtual = this.scrollType === "virtual";
      fixedTable.push(createVNode("div", mergeProps({
        "class": "".concat(prefix, "-table__body"),
        "style": containerStyle
      }, asyncLoadingProps, {
        "ref": "scrollBody",
        "onScroll": handleScroll
      }), [isVirtual && createVNode("div", {
        "style": {
          position: "absolute",
          width: "1px",
          height: "1px",
          transition: "transform .2s",
          transform: "translate(0, ".concat(this.scrollHeight, "px)")
        }
      }, null), createVNode("table", {
        "ref": "table",
        "style": {
          tableLayout: tableLayout,
          transform: isVirtual && "translate(0, ".concat(this.translateY, "px)")
        }
      }, [createVNode(TableColGroup, {
        "columns": columns
      }, null), this.renderBody(), this.renderFooter()])]));
      return fixedTable;
    },
    renderLoadingContent: function renderLoadingContent() {
      return renderTNodeJSX(this, "loading", createVNode("div", null, null));
    },
    renderFooter: function renderFooter() {
      var colspan = this.flattedColumns.length;
      var footerContent = renderTNodeJSX(this, "footer");
      return footerContent ? createVNode("tfoot", null, [createVNode("tr", null, [createVNode("td", {
        "colspan": colspan
      }, [footerContent])])]) : null;
    },
    handleScroll: function handleScroll(e) {
      this.checkScrollableToLeftOrRight();
      var _e$target = e.target,
          scrollLeft = _e$target.scrollLeft,
          scrollTop = _e$target.scrollTop;
      var direction = getScrollDirection(scrollLeft, scrollTop);

      if (direction !== ScrollDirection.UNKNOWN) {
        var scrollListenerName = direction === ScrollDirection.X ? "scroll-x" : "scroll-y";
        emitEvent(this, scrollListenerName, {
          e: e
        });
      }
    },
    checkMaxHeight: function checkMaxHeight() {
      var maxHeight = this.maxHeight;

      if (maxHeight && this.$refs.tableContent.clientHeight > maxHeight) {
        this.useFixedHeader = true;
      }
    }
  },
  render: function render() {
    var _ref4;

    var hasPagination = this.hasPagination,
        commonClass = this.commonClass,
        fixedHeader = this.fixedHeader,
        columns = this.columns,
        tableLayout = this.tableLayout,
        isLoading = this.isLoading,
        isEmpty = this.isEmpty,
        useFixedHeader = this.useFixedHeader,
        hasFixedColumns = this.hasFixedColumns;
    var body = [];

    var tableColGroup = createVNode(TableColGroup, {
      "columns": columns
    }, null);

    var tableHeader = this.renderHeader();
    var tableContent = [tableColGroup, tableHeader];
    var fixedTableContent;

    if (fixedHeader || useFixedHeader) {
      fixedTableContent = this.renderTableWithFixedHeader();
    } else {
      tableContent.push(this.renderBody());
      tableContent.push(this.renderFooter());
    }

    if (isEmpty) {
      body.push(this.renderEmptyTable());
    }

    if (hasPagination) {
      body.push(this.renderPagination());
    }

    var handleScroll = throttle(this.handleScroll, 100);
    var tableContentClass = ["".concat(prefix, "-table__content"), (_ref4 = {}, _defineProperty(_ref4, "".concat(prefix, "-table__content--scrollable-to-right"), this.scrollableToRight), _defineProperty(_ref4, "".concat(prefix, "-table__content--scrollable-to-left"), this.scrollableToLeft), _ref4)];
    var width;
    var _this$$refs = this.$refs,
        tableContentEl = _this$$refs.tableContent,
        tableEl = _this$$refs.table;

    if (!hasFixedColumns && (tableContentEl === null || tableContentEl === void 0 ? void 0 : tableContentEl.clientWidth) < (tableEl === null || tableEl === void 0 ? void 0 : tableEl.clientWidth)) {
      width = "".concat(tableEl.clientWidth, "px");
    }

    return createVNode("div", {
      "class": commonClass,
      "style": {
        width: width
      }
    }, [createVNode(Loading, {
      "loading": isLoading,
      "showOverlay": true,
      "text": this.renderLoadingContent
    }, {
      "default": function _default() {
        return [createVNode("div", {
          "ref": "tableContent",
          "class": tableContentClass,
          "onScroll": handleScroll
        }, [fixedTableContent || createVNode("table", {
          "ref": "table",
          "style": {
            tableLayout: tableLayout
          }
        }, [tableContent])]), body];
      }
    })]);
  }
}));

export { _BaseTable as default };
//# sourceMappingURL=index.js.map
