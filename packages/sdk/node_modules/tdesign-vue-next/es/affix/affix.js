/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

import _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';
import { defineComponent, getCurrentInstance, ref, watch, onMounted, nextTick, onBeforeUnmount, createVNode } from 'vue';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import isFunction from 'lodash/isFunction';
import { prefix } from '../config.js';
import { getScrollContainer, on, off } from '../utils/dom.js';
import props from './props.js';
import { renderTNodeJSX } from '../utils/render-tnode.js';
import '../_chunks/dep-b66bfe36.js';
import 'lodash/isString';
import '../utils/easing.js';
import 'lodash/isEmpty';
import 'lodash/isObject';

var name = "".concat(prefix, "-affix");
var _Affix = defineComponent({
  name: "TAffix",
  props: props,
  emits: ["fixedChange"],
  setup: function setup(props2, _ref) {
    var emit = _ref.emit;
    var instance = getCurrentInstance();
    var fixedTop = ref(false);
    var oldWidthHeight = ref({
      width: "0px",
      height: "0px"
    });
    var scrollContainer = ref();
    var containerHeight = ref(0);
    var ticking = ref(false);

    var calcInitValue = function calcInitValue() {
      var _containerHeight = 0;

      if (scrollContainer.value instanceof Window) {
        _containerHeight = scrollContainer.value.innerHeight;
      } else {
        _containerHeight = scrollContainer.value.clientHeight;
      }

      containerHeight.value = _containerHeight - instance.ctx.$el.clientHeight;

      var _ref2 = instance.ctx.$el.querySelector(".".concat(name)) || instance.ctx.$el,
          clientWidth = _ref2.clientWidth,
          clientHeight = _ref2.clientHeight;

      oldWidthHeight.value = {
        width: "".concat(clientWidth, "px"),
        height: "".concat(clientHeight, "px")
      };
      handleScroll();
    };

    var handleScroll = function handleScroll() {
      if (!ticking.value) {
        window.requestAnimationFrame(function () {
          var _instance$ctx$$el$get = instance.ctx.$el.getBoundingClientRect(),
              top = _instance$ctx$$el$get.top;

          var containerTop = 0;

          if (scrollContainer.value instanceof HTMLElement) {
            containerTop = scrollContainer.value.getBoundingClientRect().top;
          }

          var calcTop = top - containerTop;
          var calcBottom = containerTop + containerHeight.value - props2.offsetBottom;

          if (props2.offsetTop !== void 0 && calcTop <= props2.offsetTop) {
            fixedTop.value = containerTop + props2.offsetTop;
          } else if (props2.offsetBottom !== void 0 && top >= calcBottom) {
            fixedTop.value = calcBottom;
          } else {
            fixedTop.value = false;
          }

          ticking.value = false;
          emit("fixedChange", fixedTop.value !== false, {
            top: fixedTop.value
          });
          if (isFunction(props2.onFixedChange)) props2.onFixedChange(fixedTop.value !== false, {
            top: fixedTop.value
          });
        });
        ticking.value = true;
      }
    };

    watch(function () {
      return props2.offsetTop;
    }, function () {
      calcInitValue();
    });
    watch(function () {
      return props2.offsetBottom;
    }, function () {
      calcInitValue();
    });
    onMounted( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return nextTick();

            case 2:
              scrollContainer.value = getScrollContainer(props2.container);
              calcInitValue();
              on(scrollContainer.value, "scroll", handleScroll);
              on(window, "resize", calcInitValue);
              if (!(scrollContainer.value instanceof Window)) on(window, "scroll", handleScroll);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    onBeforeUnmount(function () {
      if (!scrollContainer.value) return;
      off(scrollContainer.value, "scroll", handleScroll);
      off(window, "resize", calcInitValue);
      if (!(scrollContainer.value instanceof Window)) off(window, "scroll", handleScroll);
    });
    return {
      fixedTop: fixedTop,
      oldWidthHeight: oldWidthHeight,
      scrollContainer: scrollContainer
    };
  },
  render: function render() {
    var oldWidthHeight = this.oldWidthHeight,
        fixedTop = this.fixedTop,
        zIndex = this.zIndex;

    if (fixedTop !== false) {
      return createVNode("div", this.$attrs, [createVNode("div", {
        "style": oldWidthHeight
      }, null), createVNode("div", {
        "class": name,
        "style": {
          zIndex: zIndex,
          top: "".concat(fixedTop, "px"),
          width: oldWidthHeight.width
        }
      }, [renderTNodeJSX(this, "default")])]);
    }

    return createVNode("div", null, [renderTNodeJSX(this, "default")]);
  }
});

export { _Affix as default };
//# sourceMappingURL=affix.js.map
