/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _typeof from '@babel/runtime/helpers/typeof';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { isVNode, defineComponent, h, createVNode, mergeProps } from 'vue';
import intersection from 'lodash/intersection';
import { prefix } from '../config.js';
import _Checkbox from './checkbox.js';
import checkboxGroupProps from './checkbox-group-props.js';
import { emitEvent } from '../utils/event.js';
import '../utils/render-tnode.js';
import 'lodash/isEmpty';
import 'lodash/isString';
import 'lodash/isFunction';
import 'lodash/isObject';
import '../utils/classnames.js';
import './props.js';
import '../utils/helper.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '@babel/runtime/helpers/slicedToArray';
import 'lodash/camelCase';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !isVNode(s);
}

var name = "".concat(prefix, "-checkbox-group");
var CheckboxGroup = defineComponent({
  name: "TCheckboxGroup",
  components: {
    Checkbox: _Checkbox
  },
  provide: function provide() {
    return {
      checkboxGroup: this
    };
  },
  props: _objectSpread({}, checkboxGroupProps),
  emits: ["change"],
  data: function data() {
    return {
      checkedMap: {},
      optionList: []
    };
  },
  computed: {
    values: function values() {
      if (this.value instanceof Array) {
        return this.value.join();
      }

      return "";
    },
    intersectionLen: function intersectionLen() {
      var values = this.optionList.map(function (item) {
        return item.value;
      });

      if (this.value instanceof Array) {
        var n = intersection(this.value, values);
        return n.length;
      }

      return 0;
    },
    isCheckAll: function isCheckAll() {
      if (this.value instanceof Array && this.value.length !== this.optionList.length - 1) {
        return false;
      }

      return this.intersectionLen === this.optionList.length - 1;
    },
    indeterminate: function indeterminate() {
      return !this.isCheckAll && this.intersectionLen < this.optionList.length && this.intersectionLen !== 0;
    },
    maxExceeded: function maxExceeded() {
      return this.max !== void 0 && this.value.length === this.max;
    }
  },
  watch: {
    values: {
      immediate: true,
      handler: function handler() {
        if (this.value instanceof Array) {
          var map = {};
          this.value.forEach(function (item) {
            map[item] = true;
          });
          this.checkedMap = map;
        }
      }
    },
    options: {
      immediate: true,
      handler: function handler() {
        var _this = this;

        if (!this.options) return [];
        this.optionList = this.options.map(function (item) {
          var r = {};

          if (_typeof(item) !== "object") {
            r = {
              label: String(item),
              value: item
            };
          } else {
            r = _objectSpread({}, item);
            r.disabled = r.disabled === void 0 ? _this.disabled : r.disabled;
          }

          return r;
        });
      }
    }
  },
  methods: {
    onCheckedChange: function onCheckedChange(p) {
      var checked = p.checked,
          checkAll = p.checkAll,
          e = p.e;

      if (checkAll) {
        this.onCheckAllChange(checked, {
          e: e
        });
      } else {
        this.handleCheckboxChange(p);
      }
    },
    getOptionListBySlots: function getOptionListBySlots(nodes) {
      var arr = [];
      nodes === null || nodes === void 0 ? void 0 : nodes.forEach(function (node) {
        var option = node.props;

        if ((option === null || option === void 0 ? void 0 : option["check-all"]) === "" || (option === null || option === void 0 ? void 0 : option["check-all"]) === true) {
          option.checkAll = true;
        }

        option && arr.push(option);
      });
      return arr;
    },
    renderLabel: function renderLabel(option) {
      if (typeof option.label === "function") {
        return option.label(h);
      }

      return option.label;
    },
    emitChange: function emitChange(val, e) {
      emitEvent(this, "change", val, {
        e: e
      });
    },
    handleCheckboxChange: function handleCheckboxChange(data) {
      var currentValue = data.option.value;

      if (this.value instanceof Array) {
        var val = _toConsumableArray(this.value);

        if (data.checked) {
          val.push(currentValue);
        } else {
          var i = val.indexOf(currentValue);
          val.splice(i, 1);
        }

        this.emitChange(val, data.e);
      } else {
        console.warn("TDesign CheckboxGroup Warn: `value` must be an array, instead of ".concat(_typeof(this.value)));
      }
    },
    getAllCheckboxValue: function getAllCheckboxValue() {
      var val = /* @__PURE__ */new Set();

      for (var i = 0, len = this.optionList.length; i < len; i++) {
        var item = this.optionList[i];
        if (item.checkAll) continue;
        val.add(item.value);
        if (this.maxExceeded) break;
      }

      return _toConsumableArray(val);
    },
    onCheckAllChange: function onCheckAllChange(checked, context) {
      var value = checked ? this.getAllCheckboxValue() : [];
      this.emitChange(value, context.e);
    }
  },
  render: function render() {
    var _this$options,
        _this2 = this;

    var children = null;

    if ((_this$options = this.options) !== null && _this$options !== void 0 && _this$options.length) {
      var _this$optionList;

      children = (_this$optionList = this.optionList) === null || _this$optionList === void 0 ? void 0 : _this$optionList.map(function (option) {
        var _slot;

        return createVNode(_Checkbox, mergeProps({
          "key": option.value
        }, option, {
          "checked": _this2.checkedMap[option.value]
        }), _isSlot(_slot = _this2.renderLabel(option)) ? _slot : {
          "default": function _default() {
            return [_slot];
          }
        });
      });
    } else {
      var nodes = this.$slots["default"] && this.$slots["default"](null);
      this.optionList = this.getOptionListBySlots(nodes);
      children = nodes;
    }

    return createVNode("div", {
      "class": name
    }, [children]);
  }
});

export { CheckboxGroup as default };
//# sourceMappingURL=group.js.map
