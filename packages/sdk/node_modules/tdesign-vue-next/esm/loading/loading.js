/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { defineComponent, ref, computed, watch, onMounted, createVNode, withDirectives, resolveDirective } from 'vue';
import GradientIcon from './icon/gradient.js';
import { prefix } from '../config.js';
import { SIZE_CLASSNAMES } from '../utils/classnames.js';
import { addClass, removeClass } from '../utils/dom.js';
import { renderTNodeJSX, renderContent } from '../utils/render-tnode.js';
import TransferDom from '../utils/transfer-dom.js';
import props from './props.js';
import '../_common/js/loading/circle-adapter.js';
import '../_common/js/utils/set-style.js';
import '../_common/js/utils/helper.js';
import '@babel/runtime/helpers/objectWithoutProperties';
import '../_chunks/dep-b66bfe36.js';
import 'lodash/isString';
import '../utils/easing.js';
import 'lodash/isEmpty';
import 'lodash/isFunction';
import 'lodash/isObject';

var name = "".concat(prefix, "-loading");
var centerClass = "".concat(prefix, "-loading--center");
var fullscreenClass = "".concat(prefix, "-loading__fullscreen");
var lockClass = "".concat(prefix, "-loading--lock");
var overlayClass = "".concat(prefix, "-loading__overlay");
var relativeClass = "".concat(prefix, "-loading__parent");
var fullClass = "".concat(prefix, "-loading--full");
var inheritColorClass = "".concat(prefix, "-loading--inherit-color");
var _Loading = defineComponent({
  name: "TLoading",
  directives: {
    TransferDom: TransferDom
  },
  props: props,
  setup: function setup(props2, _ref) {
    var slots = _ref.slots;
    var delayShowLoading = ref(false);

    var countDelay = function countDelay() {
      delayShowLoading.value = false;
      var timer = setTimeout(function () {
        delayShowLoading.value = true;
        clearTimeout(timer);
      }, props2.delay);
    };

    var delayCounted = computed(function () {
      return Boolean(!props2.delay || props2.delay && delayShowLoading.value);
    });
    var styles = computed(function () {
      var styles2 = {};

      if (props2.zIndex !== void 0) {
        styles2.zIndex = props2.zIndex;
      }

      if (!["small", "medium", "large"].includes(props2.size)) {
        styles2["font-size"] = props2.size;
      }

      return styles2;
    });
    var hasContent = computed(function () {
      return Boolean(props2["default"] || slots["default"] || props2.content || slots.content);
    });
    var lockFullscreen = computed(function () {
      return props2.preventScrollThrough && props2.fullscreen;
    });
    var showText = computed(function () {
      return Boolean(props2.text || slots.text);
    });
    var showWrapLoading = computed(function () {
      return hasContent.value && props2.loading && delayCounted.value;
    });
    var showNormalLoading = computed(function () {
      return !hasContent.value && props2.loading && delayCounted.value;
    });
    var classes = computed(function () {
      var baseClasses = [centerClass, SIZE_CLASSNAMES[props2.size], _defineProperty({}, inheritColorClass, props2.inheritColor)];
      var fullScreenClasses = [name, fullscreenClass, centerClass, overlayClass];
      return {
        baseClasses: baseClasses,
        attachClasses: baseClasses.concat([name, fullClass, _defineProperty({}, overlayClass, props2.showOverlay)]),
        withContentClasses: baseClasses.concat([name, fullClass, _defineProperty({}, overlayClass, props2.showOverlay)]),
        fullScreenClasses: fullScreenClasses,
        normalClasses: baseClasses.concat([name])
      };
    });
    var loadingRef = computed(function () {
      return props2.loading;
    });
    watch([loadingRef], function (_ref5) {
      var _ref6 = _slicedToArray(_ref5, 1),
          isLoading = _ref6[0];

      if (isLoading) {
        countDelay();
        lockFullscreen.value && addClass(document.body, lockClass);
      } else {
        lockFullscreen.value && removeClass(document.body, lockClass);
      }
    });
    onMounted(function () {
      props2.delay && countDelay();
    });
    return {
      delayShowLoading: delayShowLoading,
      styles: styles,
      showText: showText,
      hasContent: hasContent,
      classes: classes,
      lockFullscreen: lockFullscreen,
      showWrapLoading: showWrapLoading,
      showNormalLoading: showNormalLoading
    };
  },
  render: function render() {
    var _this$classes = this.classes,
        fullScreenClasses = _this$classes.fullScreenClasses,
        baseClasses = _this$classes.baseClasses,
        withContentClasses = _this$classes.withContentClasses,
        attachClasses = _this$classes.attachClasses,
        normalClasses = _this$classes.normalClasses;

    var defaultIndicator = createVNode(GradientIcon, {
      "size": this.size
    }, null);

    var indicator = this.loading && renderTNodeJSX(this, "indicator", defaultIndicator);

    var text = this.showText && createVNode("div", {
      "class": "".concat(prefix, "-loading__text")
    }, [renderTNodeJSX(this, "text")]);

    if (this.fullscreen) {
      if (!this.loading) return null;
      return withDirectives(createVNode("div", {
        "class": fullScreenClasses,
        "style": this.styles
      }, [createVNode("div", {
        "class": baseClasses
      }, [indicator, text])]), [[resolveDirective("transfer-dom"), this.attach]]);
    }

    if (this.hasContent) {
      return createVNode("div", {
        "class": relativeClass
      }, [renderContent(this, "default", "content"), this.showWrapLoading && createVNode("div", {
        "class": withContentClasses,
        "style": this.styles
      }, [indicator, text])]);
    }

    if (this.attach) {
      return withDirectives(createVNode("div", {
        "class": attachClasses,
        "style": this.styles
      }, [indicator, text]), [[resolveDirective("transfer-dom"), this.attach]]);
    }

    return createVNode("div", {
      "class": normalClasses,
      "style": this.styles
    }, [indicator, text]);
  }
});

export { _Loading as default };
//# sourceMappingURL=loading.js.map
