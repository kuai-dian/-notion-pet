/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _typeof = require('@babel/runtime/helpers/typeof');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var vue = require('vue');
var config = require('../config.js');
var utils_classnames = require('../utils/classnames.js');
var textarea_props = require('./props.js');
var utils_helper = require('../utils/helper.js');
var textarea_calcTextareaHeight = require('./calcTextareaHeight.js');
var utils_event = require('../utils/event.js');
var utils_renderTnode = require('../utils/render-tnode.js');
require('@babel/runtime/helpers/objectWithoutProperties');
require('@babel/runtime/helpers/slicedToArray');
require('lodash/camelCase');
require('lodash/isEmpty');
require('lodash/isString');
require('lodash/isFunction');
require('lodash/isObject');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var name = "".concat(config.prefix, "-textarea");
var TEXTAREA_WRAP_CLASS = "".concat(config.prefix, "-textarea__wrap");
var TEXTAREA_TIPS_CLASS = "".concat(config.prefix, "-textarea__tips");
var TEXTAREA_LIMIT = "".concat(name, "__limit");

function getValidAttrs(obj) {
  var newObj = {};
  Object.keys(obj).forEach(function (key) {
    if (typeof obj[key] !== "undefined") {
      newObj[key] = obj[key];
    }
  });
  return newObj;
}

var _Textarea = vue.defineComponent({
  name: "TTextarea",
  inheritAttrs: false,
  props: _objectSpread({}, textarea_props["default"]),
  emits: ["keydown", "keyup", "keypress", "focus", "blur", "change", "update:value"],
  data: function data() {
    return {
      focused: false,
      mouseHover: false,
      textareaStyle: {}
    };
  },
  computed: {
    textareaClasses: function textareaClasses() {
      var _ref;

      return [name, (_ref = {}, _defineProperty__default["default"](_ref, "".concat(config.prefix, "-is-disabled"), this.disabled), _defineProperty__default["default"](_ref, "".concat(config.prefix, "-is-readonly"), this.readonly), _ref)];
    },
    inputAttrs: function inputAttrs() {
      return getValidAttrs({
        autofocus: this.autofocus,
        disabled: this.disabled,
        readonly: this.readonly,
        placeholder: this.placeholder,
        maxlength: this.maxlength || void 0,
        name: this.name || void 0
      });
    },
    characterNumber: function characterNumber() {
      var characterInfo = utils_helper.getCharacterLength(String(this.value));

      if (_typeof__default["default"](characterInfo) === "object") {
        return characterInfo.length;
      }

      return characterInfo;
    }
  },
  watch: {
    value: function value() {
      this.adjustTextareaHeight();
    }
  },
  mounted: function mounted() {
    this.adjustTextareaHeight();
  },
  methods: {
    adjustTextareaHeight: function adjustTextareaHeight() {
      if (this.autosize === true) {
        this.textareaStyle = textarea_calcTextareaHeight["default"](this.$refs.refTextareaElem);
      } else if (_typeof__default["default"](this.autosize) === "object") {
        var _this$autosize = this.autosize,
            minRows = _this$autosize.minRows,
            maxRows = _this$autosize.maxRows;
        this.textareaStyle = textarea_calcTextareaHeight["default"](this.$refs.refTextareaElem, minRows, maxRows);
      } else if (this.$attrs.rows) {
        this.textareaStyle = {
          height: "auto",
          minHeight: "auto"
        };
      }
    },
    focus: function focus() {
      var input = this.$refs.refInputElem;
      input === null || input === void 0 ? void 0 : input.focus();
    },
    blur: function blur() {
      var input = this.$refs.refInputElem;
      input === null || input === void 0 ? void 0 : input.blur();
    },
    handleInput: function handleInput(e) {
      if (e.isComposing || e.inputType === "insertCompositionText") return;
      this.inputValueChangeHandle(e);
    },
    onCompositionend: function onCompositionend(e) {
      this.inputValueChangeHandle(e);
    },
    inputValueChangeHandle: function inputValueChangeHandle(e) {
      var _this = this;

      var target = e.target;
      var val = target.value;

      if (this.maxcharacter && this.maxcharacter >= 0) {
        var stringInfo = utils_helper.getCharacterLength(val, this.maxcharacter);
        val = _typeof__default["default"](stringInfo) === "object" && stringInfo.characters;
      }

      this.$emit("update:value", val);
      utils_event.emitEvent(this, "change", val, {
        e: e
      });
      this.$nextTick(function () {
        return _this.setInputValue(val);
      });
      this.adjustTextareaHeight();
    },
    setInputValue: function setInputValue() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var textareaElem = this.$refs.refTextareaElem;
      var sV = String(v);

      if (!textareaElem) {
        return;
      }

      if (textareaElem.value !== sV) {
        textareaElem.value = sV;
      }
    },
    emitKeyDown: function emitKeyDown(e) {
      if (this.disabled) return;
      utils_event.emitEvent(this, "keydown", this.value, {
        e: e
      });
    },
    emitKeyUp: function emitKeyUp(e) {
      if (this.disabled) return;
      utils_event.emitEvent(this, "keyup", this.value, {
        e: e
      });
    },
    emitKeypress: function emitKeypress(e) {
      if (this.disabled) return;
      utils_event.emitEvent(this, "keypress", this.value, {
        e: e
      });
    },
    emitFocus: function emitFocus(e) {
      if (this.disabled) return;
      this.focused = true;
      utils_event.emitEvent(this, "focus", this.value, {
        e: e
      });
    },
    emitBlur: function emitBlur(e) {
      this.focused = false;
      utils_event.emitEvent(this, "blur", this.value, {
        e: e
      });
    }
  },
  render: function render() {
    var _ref2, _String;

    var inputEvents = getValidAttrs({
      onFocus: this.emitFocus,
      onBlur: this.emitBlur,
      onKeydown: this.emitKeyDown,
      onKeyup: this.emitKeyUp,
      onKeypress: this.emitKeypress
    });
    var classes = ["".concat(name, "__inner"), (_ref2 = {}, _defineProperty__default["default"](_ref2, "".concat(config.prefix, "-is-").concat(this.status), this.status), _defineProperty__default["default"](_ref2, utils_classnames["default"].STATUS.disabled, this.disabled), _defineProperty__default["default"](_ref2, utils_classnames["default"].STATUS.focused, this.focused), _defineProperty__default["default"](_ref2, "".concat(config.prefix, "-resize-none"), this.maxlength), _ref2), "narrow-scrollbar"];

    var textareaNode = vue.createVNode("div", {
      "class": this.textareaClasses
    }, [vue.createVNode("textarea", vue.mergeProps({
      "onInput": this.handleInput,
      "onCompositionend": this.onCompositionend,
      "ref": "refTextareaElem",
      "value": this.value,
      "style": this.textareaStyle,
      "class": classes
    }, this.$attrs, inputEvents, this.inputAttrs), null), this.maxcharacter && vue.createVNode("span", {
      "class": TEXTAREA_LIMIT
    }, ["".concat(this.characterNumber, "/").concat(this.maxcharacter)]), !this.maxcharacter && this.maxlength ? vue.createVNode("span", {
      "class": TEXTAREA_LIMIT
    }, ["".concat(this.value ? (_String = String(this.value)) === null || _String === void 0 ? void 0 : _String.length : 0, "/").concat(this.maxlength)]) : null]);

    var tips = utils_renderTnode.renderTNodeJSX(this, "tips");

    if (tips) {
      return vue.createVNode("div", {
        "class": TEXTAREA_WRAP_CLASS
      }, [textareaNode, vue.createVNode("div", {
        "class": "".concat(TEXTAREA_TIPS_CLASS, " ").concat(config.prefix, "-textarea__tips--").concat(this.status || "normal")
      }, [tips])]);
    }

    return textareaNode;
  }
});

exports["default"] = _Textarea;
//# sourceMappingURL=textarea.js.map
