/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var vue = require('vue');
var utils_mixins = require('../utils/mixins.js');
var configProvider_configReceiver = require('../config-provider/config-receiver.js');
var utils_event = require('../utils/event.js');
var timePicker_constant = require('./constant.js');
var config = require('../config.js');
require('../config-provider/zh_CN_config.js');
require('../utils/helper.js');
require('@babel/runtime/helpers/objectWithoutProperties');
require('@babel/runtime/helpers/slicedToArray');
require('lodash/camelCase');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var name = "".concat(config.prefix, "-time-picker-input-items");
var InputItems = vue.defineComponent(_objectSpread(_objectSpread({}, utils_mixins["default"](configProvider_configReceiver["default"]("timePicker"))), {}, {
  name: name,
  props: {
    format: {
      type: String,
      "default": ""
    },
    dayjs: {
      type: [Object, Array, void 0],
      "default": void 0
    },
    placeholder: {
      type: String,
      "default": ""
    },
    allowInput: {
      type: Boolean
    },
    isRangePicker: {
      type: Boolean,
      "default": false
    },
    disabled: {
      type: Boolean
    }
  },
  emits: ["change", "blurDefault", "focusDefault", "toggleMeridiem"],
  computed: {
    displayTimeList: function displayTimeList() {
      return this.isRangePicker ? this.dayjs : [this.dayjs];
    }
  },
  methods: {
    onInput: function onInput(e, type, index) {
      if (!this.allowInput) return;
      var target = e.target,
          data = e.data;
      var value = target.value;
      var format = this.$props.format;
      var curDayJs = this.displayTimeList[index];
      var number = Number(value);

      if (curDayJs[type] === "00" && number === 0 || value === "") {
        utils_event.emitEvent(this, "change", {
          value: timePicker_constant.EMPTY_VALUE,
          type: type,
          index: index
        });
      } else if ("".concat(number).length > 2) {
        number = Number(data);
      }

      var emitChange = true;

      if (!isNaN(number)) {
        switch (type) {
          case "hour":
            if (number > (/[h]{1}/.test(format) ? 12 : 24) || number < 0) {
              emitChange = false;
            }

            break;

          case "minute":
            if (number > 59 || number < 0) {
              emitChange = false;
            }

            break;

          case "second":
            if (number > 59 || number < 0) {
              emitChange = false;
            }

            break;
        }

        if (emitChange) {
          utils_event.emitEvent(this, "change", {
            value: number,
            type: type,
            index: index
          });
        }
      }

      if (curDayJs[type] !== void 0) this.setInputValue(curDayJs[type], target);
    },
    onBlur: function onBlur(e, trigger, index, input) {
      this.allowInput && utils_event.emitEvent(this, "blurDefault", e, trigger, index, input);
    },
    onFocus: function onFocus(e, trigger, index, input) {
      this.allowInput && utils_event.emitEvent(this, "focusDefault", e, trigger, index, input);
    },
    onKeydown: function onKeydown(e, type, index) {
      if (!this.allowInput) return;
      var which = e.which;
      var format = this.$props.format;
      var curDayJs = this.displayTimeList[index];

      if ([timePicker_constant.KeyboardDirection.up, timePicker_constant.KeyboardDirection.down].includes(which)) {
        if (type === "meridiem") return;
        var current = curDayJs[type] ? Number(curDayJs[type]) : 0;
        var operate = which === timePicker_constant.KeyboardDirection.up ? -1 : 1;
        var result = current + operate;

        if (type === "hour") {
          if (result > (/[h]{1}/.test(format) ? 11 : 23)) {
            result = 0;
          } else if (result < 0) {
            result = /[h]{1}/.test(format) ? 11 : 23;
          }
        } else if (result > 59) {
          result = 1;
        } else if (result < 0) {
          result = 59;
        }

        utils_event.emitEvent(this, "change", {
          value: result,
          type: type,
          index: index
        });
      } else if ([timePicker_constant.KeyboardDirection.left, timePicker_constant.KeyboardDirection.right].includes(which)) {
        var target = e.target;
        var parentNode = target.parentNode;
        var focus = which === timePicker_constant.KeyboardDirection.left ? parentNode.previousSibling : parentNode.nextSibling;

        if (focus) {
          var input = focus.querySelector("input");
          if (!input.focus) return;
          input.focus();
        }
      }
    },
    onToggleMeridiem: function onToggleMeridiem(index) {
      utils_event.emitEvent(this, "toggleMeridiem", index);
    },
    setInputValue: function setInputValue(v, input) {
      var sV = String(v);

      if (!input) {
        return;
      }

      if (input.value !== sV) {
        Object.assign(input, {
          value: sV
        });
      }
    },
    switchRenderComponent: function switchRenderComponent() {
      var _this = this;

      var _this$$props = this.$props,
          format = _this$$props.format,
          placeholder = _this$$props.placeholder,
          allowInput = _this$$props.allowInput,
          disabled = _this$$props.disabled;

      function isEmptyDayjs(val) {
        return val === void 0 || val.hour === void 0 && val.minute === void 0 && val.second === void 0;
      }

      var isEmptyVal = this.displayTimeList.every(function (date) {
        return isEmptyDayjs(date);
      });

      if (isEmptyVal) {
        return vue.createVNode("span", {
          "class": "".concat(timePicker_constant.COMPONENT_NAME, "__input-placeholder")
        }, [placeholder]);
      }

      var itemClasses = disabled ? ["".concat(timePicker_constant.COMPONENT_NAME, "__input-item"), "".concat(timePicker_constant.COMPONENT_NAME, "__input-item-disabled")] : ["".concat(timePicker_constant.COMPONENT_NAME, "__input-item")];
      var inputClass = "".concat(timePicker_constant.COMPONENT_NAME, "__input-item-input");
      var render = [];
      this.displayTimeList.forEach(function (inputTime, index) {
        if (index > 0) render.push("-");
        var hour = inputTime.hour,
            minute = inputTime.minute,
            second = inputTime.second;
        render.push(vue.createVNode("span", {
          "class": itemClasses
        }, [vue.createVNode("input", {
          "class": inputClass,
          "value": hour,
          "disabled": !allowInput,
          "onKeydown": function onKeydown(e) {
            return _this.onKeydown(e, "hour", index);
          },
          "onInput": function onInput(e) {
            return _this.onInput(e, "hour", index);
          },
          "onBlur": function onBlur(e) {
            return _this.onBlur(e, "hour", index, Number(hour));
          },
          "onFocus": function onFocus(e) {
            return _this.onFocus(e, "hour", index, Number(hour));
          }
        }, null)]));

        if (/[hH]{1,2}:m{1,2}/.test(format)) {
          render.push(vue.createVNode("span", {
            "class": itemClasses
          }, [":", vue.createVNode("input", {
            "class": inputClass,
            "value": minute,
            "disabled": !allowInput,
            "onKeydown": function onKeydown(e) {
              return _this.onKeydown(e, "minute", index);
            },
            "onInput": function onInput(e) {
              return _this.onInput(e, "minute", index);
            },
            "onBlur": function onBlur(e) {
              return _this.onBlur(e, "minute", index, Number(minute));
            },
            "onFocus": function onFocus(e) {
              return _this.onFocus(e, "minute", index, Number(minute));
            }
          }, null)]));

          if (/[hH]{1,2}:m{1,2}:s{1,2}/.test(format)) {
            render.push(vue.createVNode("span", {
              "class": itemClasses
            }, [":", vue.createVNode("input", {
              "class": inputClass,
              "value": second,
              "disabled": !allowInput,
              "onKeydown": function onKeydown(e) {
                return _this.onKeydown(e, "second", index);
              },
              "onInput": function onInput(e) {
                return _this.onInput(e, "second", index);
              },
              "onBlur": function onBlur(e) {
                return _this.onBlur(e, "second", index, Number(second));
              },
              "onFocus": function onFocus(e) {
                return _this.onFocus(e, "second", index, Number(second));
              }
            }, null)]));
          }
        }

        if (/[h]{1}/.test(format) && (format.includes("A") || format.includes("a"))) {
          var localeMeridiemList = [_this.global.anteMeridiem, _this.global.postMeridiem];
          var text = localeMeridiemList[timePicker_constant.MERIDIEM_LIST.indexOf(inputTime.meridiem.toUpperCase())];
          render[timePicker_constant.amFormat.test(format) ? "unshift" : "push"](vue.createVNode("span", {
            "class": itemClasses,
            "onClick": function onClick() {
              return allowInput && _this.onToggleMeridiem(index);
            }
          }, [vue.createVNode("input", {
            "readonly": true,
            "class": [inputClass, "".concat(inputClass, "-meridiem")],
            "value": text,
            "onKeydown": function onKeydown(e) {
              return _this.onKeydown(e, "meridiem", index);
            },
            "disabled": !allowInput
          }, null)]));
        }
      });
      return render;
    }
  },
  render: function render() {
    var classes = ["".concat(timePicker_constant.COMPONENT_NAME, "__input")];
    return vue.createVNode("div", {
      "class": classes
    }, [this.switchRenderComponent()]);
  }
}));

exports["default"] = InputItems;
//# sourceMappingURL=input-items.js.map
