/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var vue = require('vue');
var config = require('../../config.js');
var popup_index = require('../../popup/index.js');
var utils_dom = require('../../utils/dom.js');
var table_util_common = require('../util/common.js');
var utils_event = require('../../utils/event.js');
var table_baseTableProps = require('../base-table-props.js');
require('../../popup/popup.js');
require('@babel/runtime/helpers/typeof');
require('@popperjs/core');
require('../../_chunks/dep-eb6b0f94.js');
require('../../utils/classnames.js');
require('../../popup/props.js');
require('../../utils/render-tnode.js');
require('lodash/isEmpty');
require('lodash/isString');
require('lodash/isFunction');
require('lodash/isObject');
require('../../utils/set-style.js');
require('../../utils/easing.js');
require('../../utils/helper.js');
require('@babel/runtime/helpers/objectWithoutProperties');
require('@babel/runtime/helpers/slicedToArray');
require('lodash/camelCase');
require('../../utils/map-props.js');
require('lodash/kebabCase');
require('../../utils/withInstall.js');
require('../../popup/style');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var overlayStyle = {
  width: "100%",
  maxWidth: "400px",
  wordBreak: "break-all"
};
var TableCell = vue.defineComponent({
  name: "".concat(config.prefix, "-table-cell"),
  components: {
    Popup: popup_index.Popup
  },
  props: {
    onCellClick: table_baseTableProps["default"].onCellClick,
    cellData: {
      type: Object,
      "default": function _default() {
        return {};
      }
    }
  },
  data: function data() {
    return {
      offsetLeft: 0,
      isBoundary: false,
      isCutOff: false
    };
  },
  mounted: function mounted() {
    this.init();
  },
  updated: function updated() {
    this.init();
  },
  methods: {
    init: function init() {
      var _this = this;

      var fixed = this.cellData.col.fixed;
      var children = this.$parent.$refs;

      if (fixed) {
        var offsetLeft = 0;
        var fixedColumns = [];
        Object.keys(children).forEach(function (refKey) {
          var _el$cellData, _el$cellData$col;

          var el = children[refKey];

          if ((el === null || el === void 0 ? void 0 : (_el$cellData = el.cellData) === null || _el$cellData === void 0 ? void 0 : (_el$cellData$col = _el$cellData.col) === null || _el$cellData$col === void 0 ? void 0 : _el$cellData$col.fixed) === fixed) {
            fixedColumns.push(el);
          }
        });
        var indexInFixedColumns = fixedColumns.findIndex(function (el) {
          return el === _this;
        });
        fixedColumns.forEach(function (el, cur) {
          if (fixed === "right" && cur > indexInFixedColumns || fixed === "left" && cur < indexInFixedColumns) {
            var width = el.cellData.col.width;
            var clientWidth = el.$el.clientWidth;
            offsetLeft += width > 0 ? width : clientWidth;
          }
        });
        this.isBoundary = fixed === "left" ? indexInFixedColumns === fixedColumns.length - 1 : indexInFixedColumns === 0;
        this.offsetLeft = offsetLeft;
      }

      this.isCutOff = utils_dom.isNodeOverflow(this.$el);
    }
  },
  render: function render() {
    var _col$attrs,
        _this2 = this;

    var cellData = this.cellData;
    var col = cellData.col,
        colIndex = cellData.colIndex,
        row = cellData.row,
        rowIndex = cellData.rowIndex,
        customData = cellData.customData,
        customRender = cellData.customRender,
        withoutBorder = cellData.withoutBorder,
        withBorder = cellData.withBorder;
    var colKey = col.colKey,
        attrs = col.attrs,
        align = col.align,
        ellipsis = col.ellipsis,
        width = col.width,
        className = col.className,
        title = col.title,
        fixed = col.fixed;

    var style = _objectSpread({}, (_col$attrs = col.attrs) === null || _col$attrs === void 0 ? void 0 : _col$attrs.style);

    var fixedClass = [];
    var attrClass = (attrs === null || attrs === void 0 ? void 0 : attrs["class"]) || [];

    if (fixed) {
      style.position = "sticky";
      style[fixed] = "".concat(this.offsetLeft, "px");
      fixedClass.push("".concat(config.prefix, "-table__cell--fixed-").concat(fixed));

      if (this.isBoundary) {
        fixedClass.push("".concat(config.prefix, "-table__cell--fixed-").concat(fixed, "-").concat(fixed === "left" ? "last" : "first"));
      }
    }

    if (align) {
      attrClass.push("".concat(config.prefix, "-align-").concat(align));
    }

    if (width && !fixed) {
      style.overflow = "hidden";
    }

    if (withoutBorder === true) {
      style.borderLeftWidth = "0px";
    }

    if (withBorder) {
      style.borderLeft = "1px solid #E7E7E7";
    }

    if (ellipsis === true || typeof ellipsis === "function") {
      attrClass.push("".concat(config.prefix, "-text-ellipsis"));
    }

    if (className) {
      if (typeof className === "function") {
        attrClass.push(className({
          type: cellData.type,
          col: col,
          colIndex: colIndex,
          row: row,
          rowIndex: rowIndex
        }));
      } else {
        attrClass.push(className);
      }
    }

    if (["single", "multiple"].indexOf(col.type) > -1) {
      attrClass.push("".concat(config.prefix, "-table__cell--selectable"));
    }

    var record = table_util_common.getRecord(row);
    var cellContent;

    if (typeof customRender === "function") {
      var type = customData.type,
          func = customData.func;
      var baseData = {
        col: col,
        colIndex: colIndex,
        row: row,
        rowIndex: rowIndex,
        record: record
      };

      if (func === "title") {
        cellContent = customRender(vue.h, {
          col: col,
          colIndex: colIndex,
          type: type
        });
      } else if (func === "cell") {
        cellContent = customRender(vue.h, baseData);
      } else if (func === "render") {
        cellContent = customRender(vue.h, _objectSpread({
          type: type
        }, baseData));
      }
    } else {
      cellContent = vue.h(title || "");
    }

    var tdAttrs = _objectSpread(_objectSpread({}, attrs), {}, {
      "class": [].concat(fixedClass, _toConsumableArray__default["default"](attrClass)).filter(function (notEmpty) {
        return notEmpty;
      }).join(" "),
      key: colKey,
      style: style,
      onClick: function onClick(e) {
        utils_event.emitEvent(_this2, "cell-click", {
          col: col,
          colIndex: colIndex,
          row: row,
          rowIndex: rowIndex,
          e: e
        });
      }
    });

    if (ellipsis && this.isCutOff) {
      var popupCellContent = cellContent;

      if (typeof ellipsis === "function") {
        popupCellContent = ellipsis(vue.h, {
          row: row,
          col: col,
          rowIndex: rowIndex,
          colIndex: colIndex
        });
      }

      return vue.createVNode("td", tdAttrs, [vue.createVNode(popup_index.Popup, {
        "style": "display: inline;",
        "overlayStyle": overlayStyle,
        "placement": "bottom-left",
        "showArrow": false
      }, {
        "default": function _default() {
          return cellContent;
        },
        content: function content() {
          return popupCellContent;
        }
      })]);
    }

    return vue.createVNode("td", tdAttrs, [cellContent]);
  }
});

exports["default"] = TableCell;
//# sourceMappingURL=table-cell.js.map
