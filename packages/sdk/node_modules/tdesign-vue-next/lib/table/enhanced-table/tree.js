/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var vue = require('vue');
var tdesignIconsVueNext = require('tdesign-icons-vue-next');
var get = require('lodash/get');
var cloneDeep = require('lodash/cloneDeep');
var table_baseTableProps = require('../base-table-props.js');
var table_primaryTableProps = require('../primary-table-props.js');
var table_enhancedTableProps = require('../enhanced-table-props.js');
var table_util_common = require('../util/common.js');
var table_enhancedTable_treeStore = require('./tree-store.js');
require('lodash/isFunction');
require('lodash/isString');
require('@babel/runtime/helpers/classCallCheck');
require('@babel/runtime/helpers/createClass');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var cloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(cloneDeep);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var TreeData = vue.defineComponent({
  props: {
    rowKey: table_baseTableProps["default"].rowKey,
    data: table_baseTableProps["default"].data,
    columns: table_primaryTableProps["default"].columns,
    tree: table_enhancedTableProps["default"].tree
  },
  data: function data() {
    return {
      store: new table_enhancedTable_treeStore["default"](),
      dataSource: []
    };
  },
  computed: {
    rowDataKeys: function rowDataKeys() {
      return {
        rowKey: this.rowKey,
        childrenKey: this.childrenKey
      };
    },
    childrenKey: function childrenKey() {
      var _this$tree;

      return ((_this$tree = this.tree) === null || _this$tree === void 0 ? void 0 : _this$tree.childrenKey) || "children";
    },
    columnsSource: function columnsSource() {
      var _this$tree2,
          _this$columns$treeNod,
          _this = this;

      var treeNodeColumnIndex = ((_this$tree2 = this.tree) === null || _this$tree2 === void 0 ? void 0 : _this$tree2.treeNodeColumnIndex) || 0;

      if ((_this$columns$treeNod = this.columns[treeNodeColumnIndex]) !== null && _this$columns$treeNod !== void 0 && _this$columns$treeNod.type) {
        treeNodeColumnIndex += 1;
      }

      var cols = _toConsumableArray__default["default"](this.columns);

      var treeNodeCol = _objectSpread({}, this.columns[treeNodeColumnIndex]);

      treeNodeCol.cell = function (h, p) {
        var cellInfo = table_util_common.getCell(_this, _objectSpread(_objectSpread({}, p), {}, {
          col: _this.columns[treeNodeColumnIndex]
        }));

        var currentState = _this.store.treeDataMap.get(get__default["default"](p.row, _this.rowKey));

        var colStyle = _this.getTreeNodeStyle(currentState === null || currentState === void 0 ? void 0 : currentState.level);

        var childrenNodes = get__default["default"](p.row, _this.childrenKey);

        if (childrenNodes && childrenNodes instanceof Array) {
          var _this$store$treeDataM;

          var IconNode = (_this$store$treeDataM = _this.store.treeDataMap.get(get__default["default"](p.row, _this.rowKey))) !== null && _this$store$treeDataM !== void 0 && _this$store$treeDataM.expanded ? tdesignIconsVueNext.MinusRectangleIcon : tdesignIconsVueNext.AddRectangleIcon;
          return vue.createVNode("div", {
            "style": colStyle
          }, [!!childrenNodes.length && vue.createVNode(IconNode, {
            "style": {
              marginRight: "8px"
            },
            "onClick": function onClick() {
              return _this.toggleExpandData(p);
            }
          }, null), cellInfo]);
        }

        return vue.createVNode("div", {
          "style": colStyle
        }, [cellInfo]);
      };

      cols[treeNodeColumnIndex] = treeNodeCol;
      return cols;
    }
  },
  watch: {
    data: {
      immediate: true,
      handler: function handler(val) {
        this.dataSource = cloneDeep__default["default"](val);
        this.store.initialTreeStore(this.dataSource, this.columns, this.rowDataKeys);
      }
    }
  },
  unmounted: function unmounted() {
    var _this$store$treeDataM2;

    (_this$store$treeDataM2 = this.store.treeDataMap) === null || _this$store$treeDataM2 === void 0 ? void 0 : _this$store$treeDataM2.clear();
    this.store = null;
  },
  methods: {
    getTreeNodeStyle: function getTreeNodeStyle(level) {
      var _this$tree3;

      if (!level) return;
      var indent = ((_this$tree3 = this.tree) === null || _this$tree3 === void 0 ? void 0 : _this$tree3.indent) || 24;
      return {
        paddingLeft: "".concat(level * indent, "px")
      };
    },
    toggleExpandData: function toggleExpandData(p) {
      this.store.toggleExpandData(p, this.dataSource, this.rowDataKeys);
    },
    setData: function setData(key, newRowData) {
      var rowIndex = this.store.updateData(key, newRowData, this.dataSource, this.rowDataKeys);
      this.dataSource[rowIndex] = newRowData;
    },
    getData: function getData(key) {
      return this.store.getData(key);
    },
    remove: function remove(key) {
      this.store.remove(key, this.dataSource, this.rowDataKeys);
    },
    appendTo: function appendTo(key, newData) {
      this.store.appendTo(key, newData, this.dataSource, this.rowDataKeys);
    }
  }
});

exports["default"] = TreeData;
//# sourceMappingURL=tree.js.map
