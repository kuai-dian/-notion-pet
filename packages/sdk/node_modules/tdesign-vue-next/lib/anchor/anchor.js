/**
 * tdesign v0.8.0
 * (c) 2022 tdesign
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var vue = require('vue');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var utils_classnames = require('../utils/classnames.js');
var anchor_utils = require('./utils.js');
var utils_dom = require('../utils/dom.js');
var anchor_props = require('./props.js');
var utils_renderTnode = require('../utils/render-tnode.js');
var affix_index = require('../affix/index.js');
var anchor_constant = require('./constant.js');
var utils_event = require('../utils/event.js');
require('../config.js');
require('../_chunks/dep-eb6b0f94.js');
require('lodash/isString');
require('../utils/easing.js');
require('lodash/isEmpty');
require('lodash/isFunction');
require('lodash/isObject');
require('../affix/affix.js');
require('../affix/props.js');
require('../utils/withInstall.js');
require('../affix/style');
require('../utils/helper.js');
require('@babel/runtime/helpers/objectWithoutProperties');
require('@babel/runtime/helpers/slicedToArray');
require('lodash/camelCase');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _isSlot(s) {
  return typeof s === 'function' || Object.prototype.toString.call(s) === '[object Object]' && !vue.isVNode(s);
}

var ANCHOR_LINE_CLASSNAME = "".concat(anchor_constant.COMPONENT_NAME, "__line");
var ANCHOR_LINE_CURSOR_CLASSNAME = "".concat(anchor_constant.COMPONENT_NAME, "__line-cursor");
var _Anchor = vue.defineComponent({
  name: "TAnchor",
  provide: function provide() {
    return {
      tAnchor: this
    };
  },
  props: _objectSpread({}, anchor_props["default"]),
  emits: ["change", "click"],
  data: function data() {
    return {
      links: [],
      active: "",
      scrollContainer: null,
      activeLineStyle: {}
    };
  },
  watch: {
    attach: function attach() {
      if (this.scrollContainer) {
        utils_dom.off(this.scrollContainer, "scroll", this.handleScroll);
      }

      this.getScrollContainer();
    }
  },
  mounted: function mounted() {
    var _this = this;

    return _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
      var active;
      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              active = _this.active;

              _this.getScrollContainer();

              if (!active) {
                _context.next = 6;
                break;
              }

              _context.next = 5;
              return vue.nextTick();

            case 5:
              _this.handleScrollTo(active);

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }))();
  },
  unmounted: function unmounted() {
    if (!this.scrollContainer) return;
    utils_dom.off(this.scrollContainer, "scroll", this.handleScroll);
  },
  methods: {
    getScrollContainer: function getScrollContainer() {
      var container = this.container;
      this.scrollContainer = utils_dom.getScrollContainer(container);
      utils_dom.on(this.scrollContainer, "scroll", this.handleScroll);
      this.handleScroll();
    },
    getAnchorTarget: function getAnchorTarget(link) {
      var matcher = link.match(anchor_utils.ANCHOR_SHARP_REGEXP);

      if (!matcher) {
        return;
      }

      var anchor = document.getElementById(matcher[1]);

      if (!anchor) {
        return;
      }

      return anchor;
    },
    registerLink: function registerLink(link) {
      var links = this.links;

      if (!anchor_utils.ANCHOR_SHARP_REGEXP.test(link) || links.indexOf(link) !== -1) {
        return;
      }

      links.push(link);
    },
    unregisterLink: function unregisterLink(link) {
      this.links = this.links.filter(function (each) {
        return each !== link;
      });
    },
    setCurrentActiveLink: function setCurrentActiveLink(link) {
      var _this2 = this;

      return _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
        var active;
        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                active = _this2.active;

                if (!(active === link)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                _this2.active = link;

                _this2.emitChange(link, active);

                _context2.next = 7;
                return vue.nextTick();

              case 7:
                _this2.updateActiveLine();

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    updateActiveLine: function updateActiveLine() {
      var ele = this.$el.querySelector(".".concat(utils_classnames["default"].STATUS.active, ">a"));

      if (!ele) {
        this.activeLineStyle = null;
        return;
      }

      var top = ele.offsetTop,
          height = ele.offsetHeight;
      this.activeLineStyle = {
        top: "".concat(top, "px"),
        height: "".concat(height, "px"),
        opacity: 1
      };
    },
    emitChange: function emitChange(currentLink, prevLink) {
      utils_event.emitEvent(this, "change", currentLink, prevLink);
    },
    handleLinkClick: function handleLinkClick(link) {
      utils_event.emitEvent(this, "click", link);
    },
    handleScrollTo: function handleScrollTo(link) {
      var _this3 = this;

      return _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3() {
        var anchor, scrollContainer, targetOffset, scrollTop, offsetTop, top;
        return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                anchor = _this3.getAnchorTarget(link);

                _this3.setCurrentActiveLink(link);

                if (anchor) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return");

              case 4:
                _this3.handleScrollLock = true;
                scrollContainer = _this3.scrollContainer, targetOffset = _this3.targetOffset;
                scrollTop = utils_dom.getScroll(scrollContainer);
                offsetTop = anchor_utils.getOffsetTop(anchor, scrollContainer);
                top = scrollTop + offsetTop - targetOffset;
                _context3.next = 11;
                return utils_dom.scrollTo(top, {
                  container: scrollContainer
                });

              case 11:
                _this3.handleScrollLock = false;

              case 12:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    handleScroll: function handleScroll() {
      var _this4 = this;

      if (this.handleScrollLock) return;
      var links = this.links,
          bounds = this.bounds,
          targetOffset = this.targetOffset;
      var filters = [];
      var active = "";
      links.forEach(function (link) {
        var anchor = _this4.getAnchorTarget(link);

        if (!anchor) {
          return;
        }

        var top = anchor_utils.getOffsetTop(anchor, _this4.scrollContainer);

        if (top < bounds + targetOffset) {
          filters.push({
            link: link,
            top: top
          });
        }
      });

      if (filters.length) {
        var latest = filters.reduce(function (prev, cur) {
          return prev.top > cur.top ? prev : cur;
        });
        active = latest.link;
      }

      this.setCurrentActiveLink(active);
    },
    renderCursor: function renderCursor() {
      var titleContent = utils_renderTnode.renderTNodeJSX(this, "cursor");
      return titleContent || vue.createVNode("div", {
        "class": ANCHOR_LINE_CURSOR_CLASSNAME
      }, null);
    }
  },
  render: function render() {
    var children = this.$slots["default"],
        size = this.size,
        affixProps = this.affixProps,
        activeLineStyle = this.activeLineStyle,
        $attrs = this.$attrs;
    var className = [anchor_constant.COMPONENT_NAME, utils_classnames["default"].SIZE[size]];

    var content = vue.createVNode("div", vue.mergeProps({
      "class": className
    }, $attrs), [vue.createVNode("div", {
      "class": ANCHOR_LINE_CLASSNAME
    }, [vue.createVNode("div", {
      "class": "".concat(ANCHOR_LINE_CURSOR_CLASSNAME, "-wrapper"),
      "style": activeLineStyle
    }, [this.renderCursor()])]), children && children(null)]);

    if (affixProps) {
      return vue.createVNode(affix_index.Affix, affixProps, _isSlot(content) ? content : {
        "default": function _default() {
          return [content];
        }
      });
    }

    return content;
  }
});

exports["default"] = _Anchor;
//# sourceMappingURL=anchor.js.map
